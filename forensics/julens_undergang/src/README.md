# Challenge Generation

For this challenge, users get access to a packet capture with both unencrypted and encrypted traffic.
The encrypted traffic uses TLS and with RSA - `TLS_RSA_WITH_AES_256_GCM_SHA384` - using a specific RSA key we generate.
The prime factors of the key modulo has been uploaded to factorDB, so the idea is for the user to find this, recreate the private key, and enter a PEM-formatted version in Wireshark for automatic decryption.

The key is generated with [gen_keys.py](gen_keys.py), which saves the parameters in a text file, as well as a PEM- and PKCS8-formatted private key.
All services are setup to use the same private key for all traffic. In addition, a self-signed certificate is created for TLS.

All traffic is simulated with [gen_network_traffic.py](gen_network_traffic.py), which runs both a HTTP, HTTPS, SMTP, and Instant Messaging (custom) server.
It has been set up so new clients can easily be created and send various message types between each other, e.g.:

The custom Instant Messaging protocol is unencrypted and used as an old and deprecated custom protocol.
The small server for this is implemented in [im_server.py](im_server.py).

This makes it simple to run many different simulations - with sleeps in between for realism.

The folder `/static` contains lots of static files that can be requested, e.g. web pages, images, and emails.
The generated traffic contains requests to these web pages (and their images) for different clients to simulate real use - both over HTTP and HTTPS.
A few emails are also sent between specific clients, all with TLS. The email `plan.eml` contains the flag.

Traffic is generated by running Wireshark in listen mode while executing the traffic generation script.
When done, it is exported (filtering out any unwanted extra traffic). At the end, `tracewrangler` is used to replace localhost addresses with various fake IP addresses for realism.
